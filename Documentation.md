# Sprint To-Do App Documentation

This document provides a comprehensive explanation of the Sprint To-Do App codebase. The app is a modern, client-side task management tool that organizes work into "Sprints" with progress tracking and persistent storage.

---

## 1. Project Overview

The application is built using a modern frontend stack:
- **HTML5**: Semantic structure and templating.
- **CSS3**: Custom properties, Glassmorphism design, and keyframe animations.
- **Vanilla JavaScript**: State management, DOM manipulation, and LocalStorage integration.
- **LocalStorage**: Ensures data persists across browser sessions without a backend.

---

## 2. File Structure

- `index.html`: The entry point and structural layout.
- `styles.css`: The "look and feel," including the design system.
- `app.js`: The "brain" of the application handling logic and events.
- `Claude.md`: Original requirements document.

---

## 3. HTML Architecture (`index.html`)

The HTML is designed as a single-page application (SPA) container.

### Key Sections
- **Main Content**: Divided into "Create Sprint", "Active Sprints", and "Completed Sprints".
- **Modals**: Used for context-specific actions (e.g., adding a task).
- **Templates**: Crucial for dynamic rendering! Instead of building complex strings in JS, we use `<template>` tags.

### Snippet: The Sprint Template
```html
<template id="sprintTemplate">
    <div class="sprint-card" data-sprint-id="">
        <div class="sprint-header">
            <!-- Sprint metadata and actions -->
        </div>
        <div class="progress-container">
            <!-- Dynamic progress bar -->
        </div>
        <div class="tasks-container">
            <div class="tasks-list"></div>
        </div>
    </div>
</template>
```

---

## 4. Design System (`styles.css`)

The app uses a **Glassmorphism** aesthetic characterized by blurred backgrounds and translucent layers.

### CSS Variables (Custom Properties)
We define a theme using variables at the `:root` level for easy maintenance.
```css
:root {
    --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --glass-bg: rgba(255, 255, 255, 0.05);
    --glass-border: rgba(255, 255, 255, 0.1);
    --bg-dark: #0f0f23;
}
```

### Animations
Animations improve the "feel" of the app. The `fadeInUp` animation is applied to newly created cards.
```css
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
```

---

## 5. JavaScript Logic (`app.js`)

The JavaScript follows a clear "State -> Logic -> UI" flow.

### A. State Management
The `state` object is the single source of truth during runtime.
```javascript
const state = {
    sprints: [],
    completedSprints: []
};
```

### B. Persistent Storage
We sync the `state` object with browser `localStorage` whenever data changes.
```javascript
function saveToStorage() {
    localStorage.setItem(STORAGE_KEYS.SPRINTS, JSON.stringify(state.sprints));
    localStorage.setItem(STORAGE_KEYS.COMPLETED_SPRINTS, JSON.stringify(state.completedSprints));
}
```

### C. Logic Functions
Functions like `createSprint`, `addTask`, and `calculateProgress` handle data manipulation.

**Calculating Progress:**
```javascript
function calculateProgress(sprint) {
    if (!sprint.tasks || sprint.tasks.length === 0) return 0;
    const completedTasks = sprint.tasks.filter(t => t.status === 'done').length;
    return Math.round((completedTasks / sprint.tasks.length) * 100);
}
```

### D. Rendering Engine
The app uses "template cloning" to render UI components efficiently.
```javascript
function renderSprintCard(sprint, isCompleted) {
    const template = elements.sprintTemplate.content.cloneNode(true);
    const card = template.querySelector('.sprint-card');
    
    // Inject data into the cloned template
    card.dataset.sprintId = sprint.id;
    card.querySelector('.sprint-name').textContent = sprint.name;
    
    // ... logic to handle tasks and progress ...
    
    return card;
}
```

---

## 6. User Workflow

1. **Initialization**: On load, `init()` pulls data from storage and triggers the first render.
2. **Action**: User clicks "New Sprint". Event listener triggers the visibility of the form.
3. **Creation**: Form submission calls `createSprint()`, which updates `state`, saves to storage, and re-renders the active sprints section.
4. **Completion**: Checking a task box calls `updateTaskStatus()`, recalculates progress, and updates the DOM immediately.
5. **Archiving**: Clicking the "Finish" checkmark moves a sprint from `sprints[]` to `completedSprints[]`.

---

Documentation generated by **Antigravity** ðŸš€
